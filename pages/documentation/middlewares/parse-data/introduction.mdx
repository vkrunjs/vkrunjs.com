---
title: "Introduction to Parse Data"
description: "Overview and quick start guide for using the Parse Data middleware."
---

## Introduction

The `parseData` middleware in provides unified, secure, and flexible request parsing. It supports all major content types and allows fine-grained configuration at both global and route levels.

### Supported Data Sources

- **Query parameters**
- **URL parameters**
- **JSON body**
- **URL-encoded form data**
- **Multipart form data** (including file uploads)
- **Raw or text payloads**

### Key Features

- ðŸ”„ Automatic type conversion for strings â†’ numbers, booleans, and dates.
- ðŸ§© In-memory file handling for multipart uploads.
- ðŸ§° Configurable parsing per route or globally.
- ðŸ›¡ SQL injection protection with `escapeSQL`.
- ðŸ§¾ Unified MIME-type filtering and decompression support.
- ðŸ“¦ Optional `rawBody` capture for signature verification.
- âš™ï¸ Stream-safe and async-compatible for high performance.

---

## Quick Start

### Global Usage

```ts
import v from "vkrun";

const app = v.App();

// Enable Parse Data globally
app.parseData();

app.post("/example", (req: v.Request, res: v.Response) => {
  res.status(200).json({ parsed: req.body });
});

app.server().listen(3000, () => {
  console.log("âœ… Server running with Parse Data enabled");
});
```

### Route-Level Override

You can also apply `parseData()` only to specific routes:

```ts
import { parseData } from "vkrun";

router.post(
  "/upload",
  parseData({
    body: { type: "multipart/form-data", limit: 5 * 1024 * 1024 }, // 5MB
    security: { escapeSQL: true },
  }),
  (req, res) => {
    console.log(req.body, req.files);
    res.status(200).end();
  }
);
```
